Разработать ассемблер и интерпретатор для учебной виртуальной машины 
(УВМ). 
Спецификация УВМ 
Загрузка константы 
A 
Биты 0—7 
B 
Биты 8—31 
202 
Размер команды: 4 байт. Операнд: поле B. Результат: регистр-аккумулятор. 
Тест (A=202, B=553): 
Константа 
0xCA, 0x29, 0x02, 0x00 
Чтение значения из памяти 
A 
Биты 0—7 
Смещение 
B 
Биты 8—23 
156 
Размер команды: 3 байт. Операнд: значение в памяти по адресу, которым 
является сумма адреса (регистр-аккумулятор) и смещения (поле B). Результат: 
регистр-аккумулятор. 
Тест (A=156, B=268): 
0x9C, 0x0C, 0x01 
Запись значения в память 
A 
Биты 0—7 
Адрес 
B 
Биты 8—31 
93 
Размер команды: 4 байт. Операнд: регистр-аккумулятор. Результат: значение 
в памяти по адресу, которым является поле B. 
Тест (A=93, B=617): 
0x5D, 0x69, 0x02, 0x00 
Бинарная операция: вычитание 
A 
Биты 0—7 
B 
Биты 8—31 
175 
Адрес 
105 
Размер команды: 4 байт. Первый операнд: регистр-аккумулятор. Второй 
операнд: значение в памяти по адресу, которым является поле B. Результат: 
регистр-аккумулятор. 
Тест (A=175, B=455): 
0xAF, 0xC7, 0x01, 0x00 

#Этап 1. Перевод программы в промежуточное представление 
Цель: создать CLI-приложение ассемблера. Реализовать разбор текстового 
представления команд и трансляцию в промежуточное представление. 
Требования: 
1. Ассемблер должен принимать на вход аргументы командной строки: – Путь к исходному файлу с текстом программы. – Путь к двоичному файлу-результату. – Режим тестирования. 
2. Спроектировать человекочитаемый язык ассемблера, используя текстовое 
представление в духе традиционных ассемблеров (мнемоника аргумент, 
аргумент, ...). Поддержать все команды спецификации УВМ. 
3. Описать в документации (например, в README.md) спроектированный язык 
ассемблера. 
4. Реализовать транслятор, который язык ассемблера преобразует во 
внутреннее представление (например, список кортежей, объектов или 
словарей). 
5. (только для данного этапа) В режиме тестирования вывести на экран 
внутреннее представление ассемблированной программы в формате полей и 
значений, как в тесте из спецификации УВМ. 
6. Создать программу для тестов, приведенных в спецификации УВМ. 
Продемонстрировать, что ассемблер генерирует идентичные 
последовательности полей и их значений. 
7. Результат выполнения этапа сохранить в репозиторий стандартно 
оформленным коммитом.

1. **LOAD const** - Загрузка константы в аккумулятор
   - Код: 202 (0xCA)
   - Размер: 4 байта
   - Формат: A=202, B=const (24 бита)

2. **READ offset** - Чтение из памяти  
   - Код: 156 (0x9C)
   - Размер: 3 байта
   - Формат: A=156, B=offset (16 бит)

3. **WRITE address** - Запись в память
   - Код: 93 (0x5D)
   - Размер: 4 байта
   - Формат: A=93, B=address (24 бита)

4. **SUB address** - Вычитание
   - Код: 175 (0xAF)
   - Размер: 4 байта
   - Формат: A=175, B=address (24 бита)
  
  
#Этап 2. Формирование машинного кода 
Цель: реализовать логику преобразования команд в их двоичное 
представление. 
Требования: 
1. Реализовать транслятор из промежуточного в машинное представление. 
106 
2. Записать результат ассемблирования в двоичный выходной файл. 
3. Вывести на экран размер двоичного файла в байтах. 
4. В режиме тестирования вывести результат ассемблирования на экран в 
байтовом формате, как в тесте из спецификации УВМ. 
5. Создать файл на языке ассемблера, результат трансляции которого 
соответствует всем тестовым байтовым последовательностям из 
спецификации УВМ. 
6. Результат выполнения этапа сохранить в репозиторий стандартно 
оформленным коммитом. 
